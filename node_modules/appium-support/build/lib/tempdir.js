"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.open = open;
exports.path = path;
exports.staticDir = staticDir;
exports.openDir = void 0;

require("source-map-support/register");

var _fs = _interopRequireDefault(require("./fs"));

var _os = _interopRequireDefault(require("os"));

var _path = _interopRequireDefault(require("path"));

var _constants = _interopRequireDefault(require("constants"));

var _logger = _interopRequireDefault(require("./logger"));

const RDWR_EXCL = _constants.default.O_CREAT | _constants.default.O_TRUNC | _constants.default.O_RDWR | _constants.default.O_EXCL;

async function tempDir() {
  const now = new Date();

  const filePath = _path.default.join(process.env.APPIUM_TMP_DIR || _os.default.tmpdir(), [now.getFullYear(), now.getMonth(), now.getDate(), '-', process.pid, '-', (Math.random() * 0x100000000 + 1).toString(36)].join(''));

  await _fs.default.mkdir(filePath);
  return filePath;
}

async function path(rawAffixes, defaultPrefix) {
  const affixes = parseAffixes(rawAffixes, defaultPrefix);
  const name = `${affixes.prefix || ''}${affixes.suffix || ''}`;
  const tempDirectory = await tempDir();
  return _path.default.join(tempDirectory, name);
}

async function open(affixes) {
  const filePath = await path(affixes, 'f-');

  try {
    let fd = await _fs.default.open(filePath, RDWR_EXCL, 0o600);
    return {
      path: filePath,
      fd
    };
  } catch (err) {
    _logger.default.errorAndThrow(err);
  }
}

function parseAffixes(rawAffixes, defaultPrefix) {
  let affixes = {
    prefix: null,
    suffix: null
  };

  if (rawAffixes) {
    switch (typeof rawAffixes) {
      case 'string':
        affixes.prefix = rawAffixes;
        break;

      case 'object':
        affixes = rawAffixes;
        break;

      default:
        throw new Error(`Unknown affix declaration: ${affixes}`);
    }
  } else {
    affixes.prefix = defaultPrefix;
  }

  return affixes;
}

const _static = tempDir();

const openDir = tempDir;
exports.openDir = openDir;

async function staticDir() {
  return _static;
}require('source-map-support').install();


//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi90ZW1wZGlyLmpzIl0sIm5hbWVzIjpbIlJEV1JfRVhDTCIsImNuc3QiLCJPX0NSRUFUIiwiT19UUlVOQyIsIk9fUkRXUiIsIk9fRVhDTCIsInRlbXBEaXIiLCJub3ciLCJEYXRlIiwiZmlsZVBhdGgiLCJub2RlUGF0aCIsImpvaW4iLCJwcm9jZXNzIiwiZW52IiwiQVBQSVVNX1RNUF9ESVIiLCJvcyIsInRtcGRpciIsImdldEZ1bGxZZWFyIiwiZ2V0TW9udGgiLCJnZXREYXRlIiwicGlkIiwiTWF0aCIsInJhbmRvbSIsInRvU3RyaW5nIiwiZnMiLCJta2RpciIsInBhdGgiLCJyYXdBZmZpeGVzIiwiZGVmYXVsdFByZWZpeCIsImFmZml4ZXMiLCJwYXJzZUFmZml4ZXMiLCJuYW1lIiwicHJlZml4Iiwic3VmZml4IiwidGVtcERpcmVjdG9yeSIsIm9wZW4iLCJmZCIsImVyciIsImxvZyIsImVycm9yQW5kVGhyb3ciLCJFcnJvciIsIl9zdGF0aWMiLCJvcGVuRGlyIiwic3RhdGljRGlyIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUVBLE1BQU1BLFNBQVMsR0FBR0MsbUJBQUtDLE9BQUwsR0FBZUQsbUJBQUtFLE9BQXBCLEdBQThCRixtQkFBS0csTUFBbkMsR0FBNENILG1CQUFLSSxNQUFuRTs7QUFVQSxlQUFlQyxPQUFmLEdBQTBCO0FBQ3hCLFFBQU1DLEdBQUcsR0FBRyxJQUFJQyxJQUFKLEVBQVo7O0FBQ0EsUUFBTUMsUUFBUSxHQUFHQyxjQUFTQyxJQUFULENBQWNDLE9BQU8sQ0FBQ0MsR0FBUixDQUFZQyxjQUFaLElBQThCQyxZQUFHQyxNQUFILEVBQTVDLEVBQ2YsQ0FDRVQsR0FBRyxDQUFDVSxXQUFKLEVBREYsRUFDcUJWLEdBQUcsQ0FBQ1csUUFBSixFQURyQixFQUNxQ1gsR0FBRyxDQUFDWSxPQUFKLEVBRHJDLEVBRUUsR0FGRixFQUdFUCxPQUFPLENBQUNRLEdBSFYsRUFJRSxHQUpGLEVBS0UsQ0FBQ0MsSUFBSSxDQUFDQyxNQUFMLEtBQWdCLFdBQWhCLEdBQThCLENBQS9CLEVBQWtDQyxRQUFsQyxDQUEyQyxFQUEzQyxDQUxGLEVBTUVaLElBTkYsQ0FNTyxFQU5QLENBRGUsQ0FBakI7O0FBVUEsUUFBTWEsWUFBR0MsS0FBSCxDQUFTaEIsUUFBVCxDQUFOO0FBRUEsU0FBT0EsUUFBUDtBQUNEOztBQWdCRCxlQUFlaUIsSUFBZixDQUFxQkMsVUFBckIsRUFBaUNDLGFBQWpDLEVBQWdEO0FBQzlDLFFBQU1DLE9BQU8sR0FBR0MsWUFBWSxDQUFDSCxVQUFELEVBQWFDLGFBQWIsQ0FBNUI7QUFDQSxRQUFNRyxJQUFJLEdBQUksR0FBRUYsT0FBTyxDQUFDRyxNQUFSLElBQWtCLEVBQUcsR0FBRUgsT0FBTyxDQUFDSSxNQUFSLElBQWtCLEVBQUcsRUFBNUQ7QUFDQSxRQUFNQyxhQUFhLEdBQUcsTUFBTTVCLE9BQU8sRUFBbkM7QUFDQSxTQUFPSSxjQUFTQyxJQUFULENBQWN1QixhQUFkLEVBQTZCSCxJQUE3QixDQUFQO0FBQ0Q7O0FBZUQsZUFBZUksSUFBZixDQUFxQk4sT0FBckIsRUFBOEI7QUFDNUIsUUFBTXBCLFFBQVEsR0FBRyxNQUFNaUIsSUFBSSxDQUFDRyxPQUFELEVBQVUsSUFBVixDQUEzQjs7QUFDQSxNQUFJO0FBQ0YsUUFBSU8sRUFBRSxHQUFHLE1BQU1aLFlBQUdXLElBQUgsQ0FBUTFCLFFBQVIsRUFBa0JULFNBQWxCLEVBQTZCLEtBQTdCLENBQWY7QUFFQSxXQUFPO0FBQUMwQixNQUFBQSxJQUFJLEVBQUVqQixRQUFQO0FBQWlCMkIsTUFBQUE7QUFBakIsS0FBUDtBQUNELEdBSkQsQ0FJRSxPQUFPQyxHQUFQLEVBQVk7QUFDWkMsb0JBQUlDLGFBQUosQ0FBa0JGLEdBQWxCO0FBQ0Q7QUFDRjs7QUFVRCxTQUFTUCxZQUFULENBQXVCSCxVQUF2QixFQUFtQ0MsYUFBbkMsRUFBa0Q7QUFDaEQsTUFBSUMsT0FBTyxHQUFHO0FBQUNHLElBQUFBLE1BQU0sRUFBRSxJQUFUO0FBQWVDLElBQUFBLE1BQU0sRUFBRTtBQUF2QixHQUFkOztBQUNBLE1BQUlOLFVBQUosRUFBZ0I7QUFDZCxZQUFRLE9BQU9BLFVBQWY7QUFDRSxXQUFLLFFBQUw7QUFDRUUsUUFBQUEsT0FBTyxDQUFDRyxNQUFSLEdBQWlCTCxVQUFqQjtBQUNBOztBQUNGLFdBQUssUUFBTDtBQUNFRSxRQUFBQSxPQUFPLEdBQUdGLFVBQVY7QUFDQTs7QUFDRjtBQUNFLGNBQU0sSUFBSWEsS0FBSixDQUFXLDhCQUE2QlgsT0FBUSxFQUFoRCxDQUFOO0FBUko7QUFVRCxHQVhELE1BV087QUFDTEEsSUFBQUEsT0FBTyxDQUFDRyxNQUFSLEdBQWlCSixhQUFqQjtBQUNEOztBQUNELFNBQU9DLE9BQVA7QUFDRDs7QUFFRCxNQUFNWSxPQUFPLEdBQUduQyxPQUFPLEVBQXZCOztBQU9BLE1BQU1vQyxPQUFPLEdBQUdwQyxPQUFoQjs7O0FBT0EsZUFBZXFDLFNBQWYsR0FBNEI7QUFDMUIsU0FBT0YsT0FBUDtBQUNEIiwic291cmNlc0NvbnRlbnQiOlsiLyogVGhpcyBsaWJyYXJ5IGlzIG9yaWdpbmF0ZWQgZnJvbSB0ZW1wLmpzIGF0IGh0dHA6Ly9naXRodWIuY29tL2JydWNlL25vZGUtdGVtcCAqL1xuaW1wb3J0IGZzIGZyb20gJy4vZnMnO1xuaW1wb3J0IG9zIGZyb20gJ29zJztcbmltcG9ydCBub2RlUGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCBjbnN0IGZyb20gJ2NvbnN0YW50cyc7XG5pbXBvcnQgbG9nIGZyb20gJy4vbG9nZ2VyJztcblxuY29uc3QgUkRXUl9FWENMID0gY25zdC5PX0NSRUFUIHwgY25zdC5PX1RSVU5DIHwgY25zdC5PX1JEV1IgfCBjbnN0Lk9fRVhDTDtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIHRlbXBvcmFyeSBkaXJlY3RvcnkgaW4gb3MudGVtcGRpcigpIG9yIHByb2Nlc3MuZW52LkFQUElVTV9UTVBfRElSLlxuICogZS5nLlxuICogLSBObyBgcHJvY2Vzcy5lbnYuQVBQSVVNX1RNUF9ESVJgOiBgL3Zhci9mb2xkZXJzLzM0LzIyMjJzaDhuMjdkNnJjcDdqcWxrdzhrbTAwMDBnbi9UL3h4eHh4eHh4Lnl5eXlgXG4gKiAtIFdpdGggYHByb2Nlc3MuZW52LkFQUElVTV9UTVBfRElSID0gJy9wYXRoL3RvL3Jvb3QnYDogYC9wYXRoL3RvL3Jvb3QveHh4eHh4eHgueXl5eWBcbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBBIHBhdGggdG8gdGhlIHRlbXBvcmFyeSBkaXJlY3RvcnlcbiAqL1xuYXN5bmMgZnVuY3Rpb24gdGVtcERpciAoKSB7XG4gIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XG4gIGNvbnN0IGZpbGVQYXRoID0gbm9kZVBhdGguam9pbihwcm9jZXNzLmVudi5BUFBJVU1fVE1QX0RJUiB8fCBvcy50bXBkaXIoKSxcbiAgICBbXG4gICAgICBub3cuZ2V0RnVsbFllYXIoKSwgbm93LmdldE1vbnRoKCksIG5vdy5nZXREYXRlKCksXG4gICAgICAnLScsXG4gICAgICBwcm9jZXNzLnBpZCxcbiAgICAgICctJyxcbiAgICAgIChNYXRoLnJhbmRvbSgpICogMHgxMDAwMDAwMDAgKyAxKS50b1N0cmluZygzNiksXG4gICAgXS5qb2luKCcnKSk7XG4gIC8vIGNyZWF0ZXMgYSB0ZW1wIGRpcmVjdG9yeSB1c2luZyB0aGUgZGF0ZSBhbmQgYSByYW5kb20gc3RyaW5nXG5cbiAgYXdhaXQgZnMubWtkaXIoZmlsZVBhdGgpO1xuXG4gIHJldHVybiBmaWxlUGF0aDtcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBBZmZpeGVzXG4gKiBAcHJvcGVydHkge3N0cmluZ30gcHJlZml4IC0gcHJlZml4IG9mIHRoZSB0ZW1wIGRpcmVjdG9yeSBuYW1lXG4gKiBAcHJvcGVydHkge3N0cmluZ30gc3VmZml4IC0gc3VmZml4IG9mIHRoZSB0ZW1wIGRpcmVjdG9yeSBuYW1lXG4gKi9cblxuLyoqXG4gKiBHZW5lcmF0ZSBhIHRlbXBvcmFyeSBkaXJlY3RvcnkgaW4gb3MudGVtcGRpcigpIG9yIHByb2Nlc3MuZW52LkFQUElVTV9UTVBfRElSXG4gKiB3aXRoIGFyYml0cmFyeSBwcmVmaXgvc3VmZml4IGZvciB0aGUgZGlyZWN0b3J5IG5hbWUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8QWZmaXhlc30gcmF3QWZmaXhlc1xuICogQHBhcmFtIHs/c3RyaW5nfSBkZWZhdWx0UHJlZml4XG4gKiBAcmV0dXJucyB7c3RyaW5nfSAgQSBwYXRoIHRvIHRoZSB0ZW1wb3JhcnkgZGlyZWN0b3J5IHdpdGggcmF3QWZmaXhlcyBhbmQgZGVmYXVsdFByZWZpeFxuICovXG5hc3luYyBmdW5jdGlvbiBwYXRoIChyYXdBZmZpeGVzLCBkZWZhdWx0UHJlZml4KSB7XG4gIGNvbnN0IGFmZml4ZXMgPSBwYXJzZUFmZml4ZXMocmF3QWZmaXhlcywgZGVmYXVsdFByZWZpeCk7XG4gIGNvbnN0IG5hbWUgPSBgJHthZmZpeGVzLnByZWZpeCB8fCAnJ30ke2FmZml4ZXMuc3VmZml4IHx8ICcnfWA7XG4gIGNvbnN0IHRlbXBEaXJlY3RvcnkgPSBhd2FpdCB0ZW1wRGlyKCk7XG4gIHJldHVybiBub2RlUGF0aC5qb2luKHRlbXBEaXJlY3RvcnksIG5hbWUpO1xufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wZW5lZEFmZml4ZXNcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBwYXRoIC0gVGhlIHBhdGggdG8gZmlsZVxuICogQHByb3BlcnR5IHtpbnRlZ2VyfSBmZCAtIFRoZSBmaWxlIGRlc2NyaXB0b3Igb3BlbmVkXG4gKi9cblxuLyoqXG4gKiBHZW5lcmF0ZSBhIHRlbXBvcmFyeSBkaXJlY3RvcnkgaW4gb3MudGVtcGRpcigpIG9yIHByb2Nlc3MuZW52LkFQUElVTV9UTVBfRElSXG4gKiB3aXRoIGFyYml0cmFyeSBwcmVmaXgvc3VmZml4IGZvciB0aGUgZGlyZWN0b3J5IG5hbWUgYW5kIHJldHVybiBpdCBhcyBvcGVuLlxuICpcbiAqIEBwYXJhbSB7QWZmaXhlc30gYWZmaXhlc1xuICogQHJldHVybnMge09wZW5lZEFmZml4ZXN9XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIG9wZW4gKGFmZml4ZXMpIHtcbiAgY29uc3QgZmlsZVBhdGggPSBhd2FpdCBwYXRoKGFmZml4ZXMsICdmLScpO1xuICB0cnkge1xuICAgIGxldCBmZCA9IGF3YWl0IGZzLm9wZW4oZmlsZVBhdGgsIFJEV1JfRVhDTCwgMG82MDApO1xuICAgIC8vIG9wZW5zIHRoZSBmaWxlIGluIG1vZGUgMzg0XG4gICAgcmV0dXJuIHtwYXRoOiBmaWxlUGF0aCwgZmR9O1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBsb2cuZXJyb3JBbmRUaHJvdyhlcnIpO1xuICB9XG59XG5cbi8qKlxuICpcbiAqIFJldHVybnMgcHJlZml4L3N1ZmZpeCBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xBZmZpeGVzfSByYXdBZmZpeGVzXG4gKiBAcGFyYW0gez9zdHJpbmd9IGRlZmF1bHRQcmVmaXhcbiAqIEByZXR1cm5zIHtBZmZpeGVzfVxuICovXG5mdW5jdGlvbiBwYXJzZUFmZml4ZXMgKHJhd0FmZml4ZXMsIGRlZmF1bHRQcmVmaXgpIHtcbiAgbGV0IGFmZml4ZXMgPSB7cHJlZml4OiBudWxsLCBzdWZmaXg6IG51bGx9O1xuICBpZiAocmF3QWZmaXhlcykge1xuICAgIHN3aXRjaCAodHlwZW9mIHJhd0FmZml4ZXMpIHtcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgIGFmZml4ZXMucHJlZml4ID0gcmF3QWZmaXhlcztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICBhZmZpeGVzID0gcmF3QWZmaXhlcztcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gYWZmaXggZGVjbGFyYXRpb246ICR7YWZmaXhlc31gKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYWZmaXhlcy5wcmVmaXggPSBkZWZhdWx0UHJlZml4O1xuICB9XG4gIHJldHVybiBhZmZpeGVzO1xufVxuXG5jb25zdCBfc3RhdGljID0gdGVtcERpcigpO1xuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgcGF0aCB0byBhIHRlbXBvcmFyeSBkaXJlY3RvcnlcbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBBIG5ldyB0ZW1wRGlyKCkgaWYgdGVtcFJvb3REaXJlY3RvcnkgaXMgbm90IHByb3ZpZGVkXG4gKi9cbmNvbnN0IG9wZW5EaXIgPSB0ZW1wRGlyO1xuXG4vKipcbiAqIFJldHVybnMgYSBwYXRoIHRvIGEgdGVtcG9yYXJ5IGRpcmVjdG9yeSB3aGNpaCBpcyBkZWZpbmVkIGFzIHN0YXRpYyBpbiB0aGUgc2FtZSBwcm9jZXNzXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gQSB0ZW1wIGRpcmVjdG9yeSBwYXRoIHdoY2loIGlzIGRlZmluZWQgYXMgc3RhdGljIGluIHRoZSBzYW1lIHByb2Nlc3NcbiAqL1xuYXN5bmMgZnVuY3Rpb24gc3RhdGljRGlyICgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSByZXF1aXJlLWF3YWl0XG4gIHJldHVybiBfc3RhdGljO1xufVxuXG5leHBvcnQgeyBvcGVuLCBwYXRoLCBvcGVuRGlyLCBzdGF0aWNEaXIgfTtcbiJdLCJmaWxlIjoibGliL3RlbXBkaXIuanMiLCJzb3VyY2VSb290IjoiLi4vLi4ifQ==
