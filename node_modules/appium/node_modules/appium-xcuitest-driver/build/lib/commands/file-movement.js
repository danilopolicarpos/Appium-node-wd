"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getAvailableBundleIds = getAvailableBundleIds;
exports.parseContainerPath = parseContainerPath;
exports.default = exports.commands = void 0;

require("source-map-support/register");

var _lodash = _interopRequireDefault(require("lodash"));

var _appiumSupport = require("appium-support");

var _path = _interopRequireDefault(require("path"));

var _appiumIosDriver = require("appium-ios-driver");

var _logger = _interopRequireDefault(require("../logger"));

var _teen_process = require("teen_process");

var _nodeSimctl = require("node-simctl");

var _os = require("os");

var _asyncbox = require("asyncbox");

const CONTAINER_PATH_MARKER = '@';
const CONTAINER_PATH_PATTERN = new RegExp(`^${CONTAINER_PATH_MARKER}([^/]+)/(.*)`);
const CONTAINER_TYPE_SEPARATOR = ':';
const IFUSE_CONTAINER_DOCUMENTS = 'documents';
let commands = _appiumIosDriver.iosCommands.file;
exports.commands = commands;

async function verifyIFusePresence() {
  if (!(await _appiumSupport.fs.which('ifuse'))) {
    _logger.default.errorAndThrow(`'ifuse' tool is required to be installed on the machine. ` + `Install it using 'brew cask install osxfuse && brew install ifuse' or check ` + `if it is available in PATH environment variable if the tool is already installed. ` + `Current PATH value: ${process.env.PATH}`);
  }
}

async function mountDevice(device, iFuseArgs) {
  _logger.default.debug(`Starting ifuse with args '${iFuseArgs}'...`);

  try {
    await (0, _teen_process.exec)('ifuse', iFuseArgs);
  } catch (e) {
    const bundleIds = await getAvailableBundleIds(device.udid);

    _logger.default.errorAndThrow(`Cannot mount the media folder of the device with UDID ${device.udid}. ` + `Make sure osxfuse plugin has necessary permissions in System Preferences->Security & Privacy. ` + `${bundleIds} might be able to mount as '@bundleId:documents/'. ` + `Error code: ${e.code}; stderr output: ${e.stderr}`);
  }
}

function verifyIsSubPath(originalPath, root) {
  const normalizedRoot = _path.default.normalize(root);

  const normalizedPath = _path.default.normalize(_path.default.dirname(originalPath));

  if (normalizedRoot !== originalPath && !normalizedPath.startsWith(normalizedRoot)) {
    _logger.default.errorAndThrow(`'${normalizedPath}' is expected to be a subpath of '${normalizedRoot}'`);
  }
}

async function parseContainerPath(remotePath, containerRootSupplier) {
  const match = CONTAINER_PATH_PATTERN.exec(remotePath);

  if (!match) {
    _logger.default.errorAndThrow(`It is expected that package identifier ` + `starts with '${CONTAINER_PATH_MARKER}' and is separated from the ` + `relative path with a single slash. '${remotePath}' is given instead`);
  }

  let [, bundleId, relativePath] = match;
  let containerType = null;
  const typeSeparatorPos = bundleId.indexOf(CONTAINER_TYPE_SEPARATOR);

  if (typeSeparatorPos > 0 && typeSeparatorPos < bundleId.length - 1) {
    containerType = bundleId.substring(typeSeparatorPos + 1);

    _logger.default.debug(`Parsed container type: ${containerType}`);

    bundleId = bundleId.substring(0, typeSeparatorPos);
  }

  const containerRoot = _lodash.default.isFunction(containerRootSupplier) ? await containerRootSupplier(bundleId, containerType) : containerRootSupplier;

  const pathInContainer = _path.default.posix.resolve(containerRoot, relativePath);

  verifyIsSubPath(pathInContainer, containerRoot);
  return {
    bundleId,
    pathInContainer,
    containerType
  };
}

async function pushFileToSimulator(device, remotePath, base64Data) {
  const buffer = Buffer.from(base64Data, 'base64');

  if (CONTAINER_PATH_PATTERN.test(remotePath)) {
    const {
      bundleId,
      pathInContainer: dstPath
    } = await parseContainerPath(remotePath, async (appBundle, containerType) => await (0, _nodeSimctl.getAppContainer)(device.udid, appBundle, null, containerType));

    _logger.default.info(`Parsed bundle identifier '${bundleId}' from '${remotePath}'. ` + `Will put the data into '${dstPath}'`);

    if (!(await _appiumSupport.fs.exists(_path.default.dirname(dstPath)))) {
      _logger.default.debug(`The destination folder '${_path.default.dirname(dstPath)}' does not exist. Creating...`);

      await (0, _appiumSupport.mkdirp)(_path.default.dirname(dstPath));
    }

    await _appiumSupport.fs.writeFile(dstPath, buffer);
    return;
  }

  const dstFolder = await _appiumSupport.tempDir.openDir();

  const dstPath = _path.default.resolve(dstFolder, _path.default.basename(remotePath));

  try {
    await _appiumSupport.fs.writeFile(dstPath, buffer);
    await (0, _nodeSimctl.addMedia)(device.udid, dstPath);
  } finally {
    await _appiumSupport.fs.rimraf(dstFolder);
  }
}

async function pushFileToRealDevice(device, remotePath, base64Data) {
  await verifyIFusePresence();
  const mntRoot = await _appiumSupport.tempDir.openDir();
  let isUnmountSuccessful = true;

  try {
    let dstPath = _path.default.resolve(mntRoot, remotePath);

    let ifuseArgs = ['-u', device.udid, mntRoot];

    if (CONTAINER_PATH_PATTERN.test(remotePath)) {
      const {
        bundleId,
        pathInContainer,
        containerType
      } = await parseContainerPath(remotePath, mntRoot);
      dstPath = pathInContainer;

      _logger.default.info(`Parsed bundle identifier '${bundleId}' from '${remotePath}'. ` + `Will put the data into '${dstPath}'`);

      ifuseArgs = ['-u', device.udid, _lodash.default.toLower(containerType) === IFUSE_CONTAINER_DOCUMENTS ? '--documents' : '--container', bundleId, mntRoot];
    } else {
      verifyIsSubPath(dstPath, mntRoot);
    }

    await mountDevice(device, ifuseArgs);
    isUnmountSuccessful = false;

    try {
      if (!(await _appiumSupport.fs.exists(_path.default.dirname(dstPath)))) {
        _logger.default.debug(`The destination folder '${_path.default.dirname(dstPath)}' does not exist. Creating...`);

        await (0, _appiumSupport.mkdirp)(_path.default.dirname(dstPath));
      }

      await _appiumSupport.fs.writeFile(dstPath, Buffer.from(base64Data, 'base64'));
    } finally {
      (0, _asyncbox.retry)(2, async function () {
        await (0, _teen_process.exec)('umount', [mntRoot]);
      });
      isUnmountSuccessful = true;
    }
  } finally {
    if (isUnmountSuccessful) {
      await _appiumSupport.fs.rimraf(mntRoot);
    } else {
      _logger.default.warn(`Umount has failed, so not removing '${mntRoot}'`);
    }
  }
}

async function pullFromSimulator(device, remotePath, isFile) {
  let pathOnServer;

  if (CONTAINER_PATH_PATTERN.test(remotePath)) {
    const {
      bundleId,
      pathInContainer: dstPath
    } = await parseContainerPath(remotePath, async (appBundle, containerType) => await (0, _nodeSimctl.getAppContainer)(device.udid, appBundle, null, containerType));

    _logger.default.info(`Parsed bundle identifier '${bundleId}' from '${remotePath}'. ` + `Will get the data from '${dstPath}'`);

    pathOnServer = dstPath;
  } else {
    const simRoot = device.getDir();
    pathOnServer = _path.default.posix.join(simRoot, remotePath);
    verifyIsSubPath(pathOnServer, simRoot);

    _logger.default.info(`Got the full item path: ${pathOnServer}`);
  }

  if (!(await _appiumSupport.fs.exists(pathOnServer))) {
    _logger.default.errorAndThrow(`The remote ${isFile ? 'file' : 'folder'} at '${pathOnServer}' does not exist`);
  }

  const buffer = isFile ? await _appiumSupport.fs.readFile(pathOnServer) : await _appiumSupport.zip.toInMemoryZip(pathOnServer);
  return Buffer.from(buffer).toString('base64');
}

async function pullFromRealDevice(device, remotePath, isFile) {
  await verifyIFusePresence();
  const mntRoot = await _appiumSupport.tempDir.openDir();
  let isUnmountSuccessful = true;

  try {
    let dstPath = _path.default.resolve(mntRoot, remotePath);

    let ifuseArgs = ['-u', device.udid, mntRoot];

    if (CONTAINER_PATH_PATTERN.test(remotePath)) {
      const {
        bundleId,
        pathInContainer,
        containerType
      } = await parseContainerPath(remotePath, mntRoot);
      dstPath = pathInContainer;

      _logger.default.info(`Parsed bundle identifier '${bundleId}' from '${remotePath}'. ` + `Will get the data from '${dstPath}'`);

      ifuseArgs = ['-u', device.udid, _lodash.default.toLower(containerType) === IFUSE_CONTAINER_DOCUMENTS ? '--documents' : '--container', bundleId, mntRoot];
    } else {
      verifyIsSubPath(dstPath, mntRoot);
    }

    await mountDevice(device, ifuseArgs);
    isUnmountSuccessful = false;

    try {
      if (!(await _appiumSupport.fs.exists(dstPath))) {
        _logger.default.errorAndThrow(`The remote ${isFile ? 'file' : 'folder'} at '${dstPath}' does not exist`);
      }

      const buffer = isFile ? await _appiumSupport.fs.readFile(dstPath) : await _appiumSupport.zip.toInMemoryZip(dstPath);
      return Buffer.from(buffer).toString('base64');
    } finally {
      (0, _asyncbox.retry)(2, async function () {
        await (0, _teen_process.exec)('umount', [mntRoot]);
      });
      isUnmountSuccessful = true;
    }
  } finally {
    if (isUnmountSuccessful) {
      await _appiumSupport.fs.rimraf(mntRoot);
    } else {
      _logger.default.warn(`Umount has failed, so not removing '${mntRoot}'`);
    }
  }
}

async function getAvailableBundleIds(udid) {
  try {
    const {
      stdout
    } = await (0, _teen_process.exec)('ifuse', ['-u', udid, '--list-apps']);
    return stdout.split(_os.EOL).map(app => app.split(',')[0].trim()).filter(app => !_lodash.default.isEmpty(app));
  } catch (e) {
    _logger.default.warn(`Cannot get a list of bundleIds.` + `Error code: ${e}; stderr output: ${e.stderr}`);
  }

  return [];
}

commands.pushFile = async function pushFile(remotePath, base64Data) {
  if (remotePath.endsWith('/')) {
    _logger.default.errorAndThrow(`It is expected that remote path points to a file and not to a folder. ` + `'${remotePath}' is given instead`);
  }

  if (_lodash.default.isArray(base64Data)) {
    base64Data = Buffer.from(base64Data).toString('utf8');
  }

  return this.isSimulator() ? await pushFileToSimulator(this.opts.device, remotePath, base64Data) : await pushFileToRealDevice(this.opts.device, remotePath, base64Data);
};

commands.pullFile = async function pullFile(remotePath) {
  if (remotePath.endsWith('/')) {
    _logger.default.errorAndThrow(`It is expected that remote path points to a file and not to a folder. ` + `'${remotePath}' is given instead`);
  }

  return this.isSimulator() ? await pullFromSimulator(this.opts.device, remotePath, true) : await pullFromRealDevice(this.opts.device, remotePath, true);
};

commands.getSimFileFullPath = async function getSimFileFullPath(remotePath) {
  let basePath = this.opts.device.getDir();
  let appName = null;

  if (this.opts.app) {
    let appNameRegex = new RegExp(`\\${_path.default.sep}([\\w-]+\\.app)`);
    let appNameMatches = appNameRegex.exec(this.opts.app);

    if (appNameMatches) {
      appName = appNameMatches[1];
    }
  }

  if (_appiumSupport.system.isWindows()) {
    if (remotePath.indexof('://') === 1) {
      remotePath = remotePath.slice(4);
    }
  } else {
    if (remotePath.indexOf('/') === 0) {
      remotePath = remotePath.slice(1);
    }
  }

  if (remotePath.startsWith(appName)) {
    let findPath = basePath;

    if (!this.opts.platformVersion || _appiumSupport.util.compareVersions(this.opts.platformVersion, '>=', '8.0')) {
      findPath = _path.default.resolve(basePath, 'Containers', 'Bundle');
    }

    findPath = findPath.replace(/\s/g, '\\ ');
    let {
      stdout
    } = await (0, _teen_process.exec)('find', [findPath, '-name', appName]);
    let appRoot = stdout.replace(/\n$/, '');
    let subPath = remotePath.substring(appName.length + 1);

    let fullPath = _path.default.resolve(appRoot, subPath);

    _logger.default.debug(`Finding app-relative file: '${fullPath}'`);

    return fullPath;
  }

  let fullPath = _path.default.resolve(basePath, remotePath);

  _logger.default.debug(`Finding sim-relative file: ${fullPath}`);

  return fullPath;
};

commands.pullFolder = async function pullFolder(remotePath) {
  if (!remotePath.endsWith('/')) {
    remotePath = `${remotePath}/`;
  }

  return this.isSimulator() ? await pullFromSimulator(this.opts.device, remotePath, false) : await pullFromRealDevice(this.opts.device, remotePath, false);
};

var _default = commands;
exports.default = _default;require('source-map-support').install();


//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9jb21tYW5kcy9maWxlLW1vdmVtZW50LmpzIl0sIm5hbWVzIjpbIkNPTlRBSU5FUl9QQVRIX01BUktFUiIsIkNPTlRBSU5FUl9QQVRIX1BBVFRFUk4iLCJSZWdFeHAiLCJDT05UQUlORVJfVFlQRV9TRVBBUkFUT1IiLCJJRlVTRV9DT05UQUlORVJfRE9DVU1FTlRTIiwiY29tbWFuZHMiLCJpb3NDb21tYW5kcyIsImZpbGUiLCJ2ZXJpZnlJRnVzZVByZXNlbmNlIiwiZnMiLCJ3aGljaCIsImxvZyIsImVycm9yQW5kVGhyb3ciLCJwcm9jZXNzIiwiZW52IiwiUEFUSCIsIm1vdW50RGV2aWNlIiwiZGV2aWNlIiwiaUZ1c2VBcmdzIiwiZGVidWciLCJlIiwiYnVuZGxlSWRzIiwiZ2V0QXZhaWxhYmxlQnVuZGxlSWRzIiwidWRpZCIsImNvZGUiLCJzdGRlcnIiLCJ2ZXJpZnlJc1N1YlBhdGgiLCJvcmlnaW5hbFBhdGgiLCJyb290Iiwibm9ybWFsaXplZFJvb3QiLCJwYXRoIiwibm9ybWFsaXplIiwibm9ybWFsaXplZFBhdGgiLCJkaXJuYW1lIiwic3RhcnRzV2l0aCIsInBhcnNlQ29udGFpbmVyUGF0aCIsInJlbW90ZVBhdGgiLCJjb250YWluZXJSb290U3VwcGxpZXIiLCJtYXRjaCIsImV4ZWMiLCJidW5kbGVJZCIsInJlbGF0aXZlUGF0aCIsImNvbnRhaW5lclR5cGUiLCJ0eXBlU2VwYXJhdG9yUG9zIiwiaW5kZXhPZiIsImxlbmd0aCIsInN1YnN0cmluZyIsImNvbnRhaW5lclJvb3QiLCJfIiwiaXNGdW5jdGlvbiIsInBhdGhJbkNvbnRhaW5lciIsInBvc2l4IiwicmVzb2x2ZSIsInB1c2hGaWxlVG9TaW11bGF0b3IiLCJiYXNlNjREYXRhIiwiYnVmZmVyIiwiQnVmZmVyIiwiZnJvbSIsInRlc3QiLCJkc3RQYXRoIiwiYXBwQnVuZGxlIiwiaW5mbyIsImV4aXN0cyIsIndyaXRlRmlsZSIsImRzdEZvbGRlciIsInRlbXBEaXIiLCJvcGVuRGlyIiwiYmFzZW5hbWUiLCJyaW1yYWYiLCJwdXNoRmlsZVRvUmVhbERldmljZSIsIm1udFJvb3QiLCJpc1VubW91bnRTdWNjZXNzZnVsIiwiaWZ1c2VBcmdzIiwidG9Mb3dlciIsIndhcm4iLCJwdWxsRnJvbVNpbXVsYXRvciIsImlzRmlsZSIsInBhdGhPblNlcnZlciIsInNpbVJvb3QiLCJnZXREaXIiLCJqb2luIiwicmVhZEZpbGUiLCJ6aXAiLCJ0b0luTWVtb3J5WmlwIiwidG9TdHJpbmciLCJwdWxsRnJvbVJlYWxEZXZpY2UiLCJzdGRvdXQiLCJzcGxpdCIsIkVPTCIsIm1hcCIsImFwcCIsInRyaW0iLCJmaWx0ZXIiLCJpc0VtcHR5IiwicHVzaEZpbGUiLCJlbmRzV2l0aCIsImlzQXJyYXkiLCJpc1NpbXVsYXRvciIsIm9wdHMiLCJwdWxsRmlsZSIsImdldFNpbUZpbGVGdWxsUGF0aCIsImJhc2VQYXRoIiwiYXBwTmFtZSIsImFwcE5hbWVSZWdleCIsInNlcCIsImFwcE5hbWVNYXRjaGVzIiwic3lzdGVtIiwiaXNXaW5kb3dzIiwiaW5kZXhvZiIsInNsaWNlIiwiZmluZFBhdGgiLCJwbGF0Zm9ybVZlcnNpb24iLCJ1dGlsIiwiY29tcGFyZVZlcnNpb25zIiwicmVwbGFjZSIsImFwcFJvb3QiLCJzdWJQYXRoIiwiZnVsbFBhdGgiLCJwdWxsRm9sZGVyIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBRUEsTUFBTUEscUJBQXFCLEdBQUcsR0FBOUI7QUFFQSxNQUFNQyxzQkFBc0IsR0FBRyxJQUFJQyxNQUFKLENBQVksSUFBR0YscUJBQXNCLGNBQXJDLENBQS9CO0FBQ0EsTUFBTUcsd0JBQXdCLEdBQUcsR0FBakM7QUFDQSxNQUFNQyx5QkFBeUIsR0FBRyxXQUFsQztBQUdBLElBQUlDLFFBQVEsR0FBR0MsNkJBQVlDLElBQTNCOzs7QUFFQSxlQUFlQyxtQkFBZixHQUFzQztBQUNwQyxNQUFJLEVBQUMsTUFBTUMs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LFFBQVA7QUFDRCxDQXpDRDs7QUEyQ0FoSCxRQUFRLENBQUNpSCxVQUFULEdBQXNCLGVBQWVBLFVBQWYsQ0FBMkJsRixVQUEzQixFQUF1QztBQUMzRCxNQUFJLENBQUNBLFVBQVUsQ0FBQzJELFFBQVgsQ0FBb0IsR0FBcEIsQ0FBTCxFQUErQjtBQUM3QjNELElBQUFBLFVBQVUsR0FBSSxHQUFFQSxVQUFXLEdBQTNCO0FBQ0Q7O0FBQ0QsU0FBTyxLQUFLNkQsV0FBTCxLQUNILE1BQU10QixpQkFBaUIsQ0FBQyxLQUFLdUIsSUFBTCxDQUFVakYsTUFBWCxFQUFtQm1CLFVBQW5CLEVBQStCLEtBQS9CLENBRHBCLEdBRUgsTUFBTWlELGtCQUFrQixDQUFDLEtBQUthLElBQUwsQ0FBVWpGLE1BQVgsRUFBbUJtQixVQUFuQixFQUErQixLQUEvQixDQUY1QjtBQUdELENBUEQ7O2VBV2UvQixRIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IHN5c3RlbSwgZnMsIHRlbXBEaXIsIG1rZGlycCwgemlwLCB1dGlsIH0gZnJvbSAnYXBwaXVtLXN1cHBvcnQnO1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgeyBpb3NDb21tYW5kcyB9IGZyb20gJ2FwcGl1bS1pb3MtZHJpdmVyJztcbmltcG9ydCBsb2cgZnJvbSAnLi4vbG9nZ2VyJztcbmltcG9ydCB7IGV4ZWMgfSBmcm9tICd0ZWVuX3Byb2Nlc3MnO1xuaW1wb3J0IHsgYWRkTWVkaWEsIGdldEFwcENvbnRhaW5lciB9IGZyb20gJ25vZGUtc2ltY3RsJztcbmltcG9ydCB7IEVPTCB9IGZyb20gJ29zJztcbmltcG9ydCB7IHJldHJ5IH0gZnJvbSAnYXN5bmNib3gnO1xuXG5jb25zdCBDT05UQUlORVJfUEFUSF9NQVJLRVIgPSAnQCc7XG4vLyBodHRwczovL3JlZ2V4MTAxLmNvbS9yL1BMZEIwRy8yXG5jb25zdCBDT05UQUlORVJfUEFUSF9QQVRURVJOID0gbmV3IFJlZ0V4cChgXiR7Q09OVEFJTkVSX1BBVEhfTUFSS0VSfShbXi9dKykvKC4qKWApO1xuY29uc3QgQ09OVEFJTkVSX1RZUEVfU0VQQVJBVE9SID0gJzonO1xuY29uc3QgSUZVU0VfQ09OVEFJTkVSX0RPQ1VNRU5UUyA9ICdkb2N1bWVudHMnO1xuXG5cbmxldCBjb21tYW5kcyA9IGlvc0NvbW1hbmRzLmZpbGU7XG5cbmFzeW5jIGZ1bmN0aW9uIHZlcmlmeUlGdXNlUHJlc2VuY2UgKCkge1xuICBpZiAoIWF3YWl0IGZzLndoaWNoKCdpZnVzZScpKSB7XG4gICAgbG9nLmVycm9yQW5kVGhyb3coYCdpZnVzZScgdG9vbCBpcyByZXF1aXJlZCB0byBiZSBpbnN0YWxsZWQgb24gdGhlIG1hY2hpbmUuIGAgK1xuICAgICAgICAgICAgICAgICAgICAgIGBJbnN0YWxsIGl0IHVzaW5nICdicmV3IGNhc2sgaW5zdGFsbCBvc3hmdXNlICYmIGJyZXcgaW5zdGFsbCBpZnVzZScgb3IgY2hlY2sgYCArXG4gICAgICAgICAgICAgICAgICAgICAgYGlmIGl0IGlzIGF2YWlsYWJsZSBpbiBQQVRIIGVudmlyb25tZW50IHZhcmlhYmxlIGlmIHRoZSB0b29sIGlzIGFscmVhZHkgaW5zdGFsbGVkLiBgICtcbiAgICAgICAgICAgICAgICAgICAgICBgQ3VycmVudCBQQVRIIHZhbHVlOiAke3Byb2Nlc3MuZW52LlBBVEh9YCk7XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gbW91bnREZXZpY2UgKGRldmljZSwgaUZ1c2VBcmdzKSB7XG4gIGxvZy5kZWJ1ZyhgU3RhcnRpbmcgaWZ1c2Ugd2l0aCBhcmdzICcke2lGdXNlQXJnc30nLi4uYCk7XG4gIHRyeSB7XG4gICAgYXdhaXQgZXhlYygnaWZ1c2UnLCBpRnVzZUFyZ3MpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgY29uc3QgYnVuZGxlSWRzID0gYXdhaXQgZ2V0QXZhaWxhYmxlQnVuZGxlSWRzKGRldmljZS51ZGlkKTtcbiAgICBsb2cuZXJyb3JBbmRUaHJvdyhgQ2Fubm90IG1vdW50IHRoZSBtZWRpYSBmb2xkZXIgb2YgdGhlIGRldmljZSB3aXRoIFVESUQgJHtkZXZpY2UudWRpZH0uIGAgK1xuICAgICAgICAgICAgICAgICAgICAgIGBNYWtlIHN1cmUgb3N4ZnVzZSBwbHVnaW4gaGFzIG5lY2Vzc2FyeSBwZXJtaXNzaW9ucyBpbiBTeXN0ZW0gUHJlZmVyZW5jZXMtPlNlY3VyaXR5ICYgUHJpdmFjeS4gYCArXG4gICAgICAgICAgICAgICAgICAgICAgYCR7YnVuZGxlSWRzfSBtaWdodCBiZSBhYmxlIHRvIG1vdW50IGFzICdAYnVuZGxlSWQ6ZG9jdW1lbnRzLycuIGAgK1xuICAgICAgICAgICAgICAgICAgICAgIGBFcnJvciBjb2RlOiAke2UuY29kZX07IHN0ZGVyciBvdXRwdXQ6ICR7ZS5zdGRlcnJ9YCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdmVyaWZ5SXNTdWJQYXRoIChvcmlnaW5hbFBhdGgsIHJvb3QpIHtcbiAgY29uc3Qgbm9ybWFsaXplZFJvb3QgPSBwYXRoLm5vcm1hbGl6ZShyb290KTtcbiAgY29uc3Qgbm9ybWFsaXplZFBhdGggPSBwYXRoLm5vcm1hbGl6ZShwYXRoLmRpcm5hbWUob3JpZ2luYWxQYXRoKSk7XG4gIC8vIElmIG9yaWdpbmFsUGF0aCBpcyByb290LCBgL2AsIG9yaWdpbmFsUGF0aCBzaG91bGQgZXF1YWwgdG8gbm9ybWFsaXplZFJvb3RcbiAgaWYgKG5vcm1hbGl6ZWRSb290ICE9PSBvcmlnaW5hbFBhdGggJiYgIW5vcm1hbGl6ZWRQYXRoLnN0YXJ0c1dpdGgobm9ybWFsaXplZFJvb3QpKSB7XG4gICAgbG9nLmVycm9yQW5kVGhyb3coYCcke25vcm1hbGl6ZWRQYXRofScgaXMgZXhwZWN0ZWQgdG8gYmUgYSBzdWJwYXRoIG9mICcke25vcm1hbGl6ZWRSb290fSdgKTtcbiAgfVxufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IENvbnRhaW5lck9iamVjdFxuICpcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBidW5kbGVJZCAtIFRoZSBwYXJzZWQgYnVuZGxlIGlkZW50aWZpZXJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBwYXRoSW5Db250YWluZXIgLSBUaGUgYWJzb2x1dGUgZnVsbCBwYXRoIG9mIHRoZSBpdGVtIG9uIHRoZSBsb2NhbCBmaWxlIHN5c3RlbVxuICogQHByb3BlcnR5IHs/c3RyaW5nfSBjb250YWluZXJUeXBlIC0gVGhlIGNvbnRhaW5lciB0eXBlXG4gKi9cblxuLyoqXG4gKiBQYXJzZXMgdGhlIGFjdHVhbCBwYXRoIGFuZCB0aGUgYnVuZGxlIGlkZW50aWZpZXIgZnJvbSB0aGUgZ2l2ZW4gcGF0aCBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVtb3RlUGF0aCAtIFRoZSBnaXZlbiBwYXRoIHN0cmluZy4gVGhlIHN0cmluZyBzaG91bGRcbiAqIG1hdGNoIGBDT05UQUlORVJfUEFUSF9QQVRURVJOYCByZWdleHAsIG90aGVyd2lzZSBhbiBlcnJvciBpcyBnb2luZ1xuICogdG8gYmUgdGhyb3duLiBBIHZhbGlkIHN0cmluZyBleGFtcGxlOiBgQGJ1bmRsZS5pZGVudGlmaWVyOmNvbnRhaW5lcl90eXBlL3JlbGF0aXZlX3BhdGhfaW5fY29udGFpbmVyYFxuICogQHBhcmFtIHtGdW5jdGlvbnxzdHJpbmd9IGNvbnRhaW5lclJvb3RTdXBwbGllciAtIEVpdGhlciBhIHN0cmluZywgdGhhdCBjb250YWluc1xuICogZnVsbCBwYXRoIHRvIHRoZSBtb3VudCByb290IGZvciByZWFsIGRldmljZXMgb3IgYSBmdW5jdGlvbiwgd2hpY2ggYWNjZXB0cyB0d28gcGFyYW1ldGVyc1xuICogKGJ1bmRsZSBpZGVudGlmaWVyIGFuZCBvcHRpb25hbCBjb250YWluZXIgdHlwZSkgYW5kIHJldHVybnMgZnVsbCBwYXRoIHRvIGNvbnRhaW5lclxuICogcm9vdCBmb2xkZXIgb24gdGhlIGxvY2FsIGZpbGUgc3lzdGVtLCBmb3IgU2ltdWxhdG9yXG4gKiBAcmV0dXJucyB7Q29udGFpbmVyT2JqZWN0fVxuICovXG5hc3luYyBmdW5jdGlvbiBwYXJzZUNvbnRhaW5lclBhdGggKHJlbW90ZVBhdGgsIGNvbnRhaW5lclJvb3RTdXBwbGllcikge1xuICBjb25zdCBtYXRjaCA9IENPTlRBSU5FUl9QQVRIX1BBVFRFUk4uZXhlYyhyZW1vdGVQYXRoKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIGxvZy5lcnJvckFuZFRocm93KGBJdCBpcyBleHBlY3RlZCB0aGF0IHBhY2thZ2UgaWRlbnRpZmllciBgICtcbiAgICAgIGBzdGFydHMgd2l0aCAnJHtDT05UQUlORVJfUEFUSF9NQVJLRVJ9JyBhbmQgaXMgc2VwYXJhdGVkIGZyb20gdGhlIGAgK1xuICAgICAgYHJlbGF0aXZlIHBhdGggd2l0aCBhIHNpbmdsZSBzbGFzaC4gJyR7cmVtb3RlUGF0aH0nIGlzIGdpdmVuIGluc3RlYWRgKTtcbiAgfVxuICBsZXQgWywgYnVuZGxlSWQsIHJlbGF0aXZlUGF0aF0gPSBtYXRjaDtcbiAgbGV0IGNvbnRhaW5lclR5cGUgPSBudWxsO1xuICBjb25zdCB0eXBlU2VwYXJhdG9yUG9zID0gYnVuZGxlSWQuaW5kZXhPZihDT05UQUlORVJfVFlQRV9TRVBBUkFUT1IpO1xuICAvLyBXZSBvbmx5IGNvbnNpZGVyIGNvbnRhaW5lciB0eXBlIGV4aXN0cyBpZiBpdHMgbGVuZ3RoIGlzIGdyZWF0ZXIgdGhhbiB6ZXJvXG4gIC8vIG5vdCBjb3VudGluZyB0aGUgY29sb25cbiAgaWYgKHR5cGVTZXBhcmF0b3JQb3MgPiAwICYmIHR5cGVTZXBhcmF0b3JQb3MgPCBidW5kbGVJZC5sZW5ndGggLSAxKSB7XG4gICAgY29udGFpbmVyVHlwZSA9IGJ1bmRsZUlkLnN1YnN0cmluZyh0eXBlU2VwYXJhdG9yUG9zICsgMSk7XG4gICAgbG9nLmRlYnVnKGBQYXJzZWQgY29udGFpbmVyIHR5cGU6ICR7Y29udGFpbmVyVHlwZX1gKTtcbiAgICBidW5kbGVJZCA9IGJ1bmRsZUlkLnN1YnN0cmluZygwLCB0eXBlU2VwYXJhdG9yUG9zKTtcbiAgfVxuICBjb25zdCBjb250YWluZXJSb290ID0gXy5pc0Z1bmN0aW9uKGNvbnRhaW5lclJvb3RTdXBwbGllcilcbiAgICA/IGF3YWl0IGNvbnRhaW5lclJvb3RTdXBwbGllcihidW5kbGVJZCwgY29udGFpbmVyVHlwZSlcbiAgICA6IGNvbnRhaW5lclJvb3RTdXBwbGllcjtcbiAgY29uc3QgcGF0aEluQ29udGFpbmVyID0gcGF0aC5wb3NpeC5yZXNvbHZlKGNvbnRhaW5lclJvb3QsIHJlbGF0aXZlUGF0aCk7XG4gIHZlcmlmeUlzU3ViUGF0aChwYXRoSW5Db250YWluZXIsIGNvbnRhaW5lclJvb3QpO1xuICByZXR1cm4ge2J1bmRsZUlkLCBwYXRoSW5Db250YWluZXIsIGNvbnRhaW5lclR5cGV9O1xufVxuXG4vKipcbiAqIFNhdmUgdGhlIGdpdmVuIGJhc2U2NCBkYXRhIGNodW5rIGFzIGEgYmluYXJ5IGZpbGUgb24gdGhlIFNpbXVsYXRvciB1bmRlciB0ZXN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZXZpY2UgLSBUaGUgZGV2aWNlIG9iamVjdCwgd2hpY2ggcmVwcmVzZW50cyB0aGUgZGV2aWNlIHVuZGVyIHRlc3QuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgVGhpcyBvYmplY3QgaXMgZXhwZWN0ZWQgdG8gaGF2ZSB0aGUgYHVkaWRgIHByb3BlcnR5IGNvbnRhaW5pbmcgdGhlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWQgZGV2aWNlIElELlxuICogQHBhcmFtIHtzdHJpbmd9IHJlbW90ZVBhdGggLSBUaGUgcmVtb3RlIHBhdGggb24gdGhlIGRldmljZS4gVGhpcyB2YXJpYWJsZSBjYW4gYmUgcHJlZml4ZWQgd2l0aFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidW5kbGUgaWQsIHNvIHRoZW4gdGhlIGZpbGUgd2lsbCBiZSB1cGxvYWRlZCB0byB0aGUgY29ycmVzcG9uZGluZ1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcHBsaWNhdGlvbiBjb250YWluZXIgaW5zdGVhZCBvZiB0aGUgZGVmYXVsdCBtZWRpYSBmb2xkZXIsIGZvciBleGFtcGxlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdAY29tLm15YXBwLmJsYTpkYXRhL1JlbGF0aXZlUGF0aEluQ29udGFpbmVyLzExMS5wbmcnLiBUaGUgJ0AnIGNoYXJhY3RlciBhdCB0aGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVnaW5uaW5nIG9mIHRoZSBhcmd1bWVudCBpcyBtYW5kYXRvcnkgaW4gc3VjaCBjYXNlLiBUaGUgY29sb24gYXQgdGhlIGVuZCBvZiBidW5kbGUgaWRlbnRpZmllclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcyBvcHRpb25hbCBhbmQgaXMgdXNlZCB0byBkaXN0aW5ndWlzaCB0aGUgY29udGFpbmVyIHR5cGUuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBvc3NpYmxlIHZhbHVlcyB0aGVyZSBhcmUgJ2FwcCcsICdkYXRhJywgJ2dyb3VwcycsICc8QSBzcGVjaWZpYyBBcHAgR3JvdXAgY29udGFpbmVyPicuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBkZWZhdWx0IHZhbHVlIGlzICdhcHAnLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgcmVsYXRpdmUgZm9sZGVyIHBhdGggaXMgaWdub3JlZCBpZiB0aGUgZmlsZSBpcyBnb2luZyB0byBiZSB1cGxvYWRlZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byB0aGUgZGVmYXVsdCBtZWRpYSBmb2xkZXIgYW5kIG9ubHkgdGhlIGZpbGUgbmFtZSBpcyBjb25zaWRlcmVkIGltcG9ydGFudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlNjREYXRhIC0gQmFzZS02NCBlbmNvZGVkIGNvbnRlbnQgb2YgdGhlIGZpbGUgdG8gYmUgdXBsb2FkZWQuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHB1c2hGaWxlVG9TaW11bGF0b3IgKGRldmljZSwgcmVtb3RlUGF0aCwgYmFzZTY0RGF0YSkge1xuICBjb25zdCBidWZmZXIgPSBCdWZmZXIuZnJvbShiYXNlNjREYXRhLCAnYmFzZTY0Jyk7XG4gIGlmIChDT05UQUlORVJfUEFUSF9QQVRURVJOLnRlc3QocmVtb3RlUGF0aCkpIHtcbiAgICBjb25zdCB7IGJ1bmRsZUlkLCBwYXRoSW5Db250YWluZXI6IGRzdFBhdGggfSA9IGF3YWl0IHBhcnNlQ29udGFpbmVyUGF0aChyZW1vdGVQYXRoLFxuICAgICAgYXN5bmMgKGFwcEJ1bmRsZSwgY29udGFpbmVyVHlwZSkgPT4gYXdhaXQgZ2V0QXBwQ29udGFpbmVyKGRldmljZS51ZGlkLCBhcHBCdW5kbGUsIG51bGwsIGNvbnRhaW5lclR5cGUpKTtcbiAgICBsb2cuaW5mbyhgUGFyc2VkIGJ1bmRsZSBpZGVudGlmaWVyICcke2J1bmRsZUlkfScgZnJvbSAnJHtyZW1vdGVQYXRofScuIGAgK1xuICAgICAgYFdpbGwgcHV0IHRoZSBkYXRhIGludG8gJyR7ZHN0UGF0aH0nYCk7XG4gICAgaWYgKCFhd2FpdCBmcy5leGlzdHMocGF0aC5kaXJuYW1lKGRzdFBhdGgpKSkge1xuICAgICAgbG9nLmRlYnVnKGBUaGUgZGVzdGluYXRpb24gZm9sZGVyICcke3BhdGguZGlybmFtZShkc3RQYXRoKX0nIGRvZXMgbm90IGV4aXN0LiBDcmVhdGluZy4uLmApO1xuICAgICAgYXdhaXQgbWtkaXJwKHBhdGguZGlybmFtZShkc3RQYXRoKSk7XG4gICAgfVxuICAgIGF3YWl0IGZzLndyaXRlRmlsZShkc3RQYXRoLCBidWZmZXIpO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBkc3RGb2xkZXIgPSBhd2FpdCB0ZW1wRGlyLm9wZW5EaXIoKTtcbiAgY29uc3QgZHN0UGF0aCA9IHBhdGgucmVzb2x2ZShkc3RGb2xkZXIsIHBhdGguYmFzZW5hbWUocmVtb3RlUGF0aCkpO1xuICB0cnkge1xuICAgIGF3YWl0IGZzLndyaXRlRmlsZShkc3RQYXRoLCBidWZmZXIpO1xuICAgIGF3YWl0IGFkZE1lZGlhKGRldmljZS51ZGlkLCBkc3RQYXRoKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBhd2FpdCBmcy5yaW1yYWYoZHN0Rm9sZGVyKTtcbiAgfVxufVxuXG4vKipcbiAqIFNhdmUgdGhlIGdpdmVuIGJhc2U2NCBkYXRhIGNodW5rIGFzIGEgYmluYXJ5IGZpbGUgb24gdGhlIGRldmljZSB1bmRlciB0ZXN0LlxuICogaWZ1c2Uvb3N4ZnVzZSBzaG91bGQgYmUgaW5zdGFsbGVkIGFuZCBjb25maWd1cmVkIG9uIHRoZSB0YXJnZXQgbWFjaGluZSBpbiBvcmRlclxuICogZm9yIHRoaXMgZnVuY3Rpb24gdG8gd29yayBwcm9wZXJseS4gUmVhZCBodHRwczovL2dpdGh1Yi5jb20vbGliaW1vYmlsZWRldmljZS9pZnVzZVxuICogYW5kIGh0dHBzOi8vZ2l0aHViLmNvbS9vc3hmdXNlL29zeGZ1c2Uvd2lraS9GQVEgZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGV2aWNlIC0gVGhlIGRldmljZSBvYmplY3QsIHdoaWNoIHJlcHJlc2VudHMgdGhlIGRldmljZSB1bmRlciB0ZXN0LlxuICogICAgICAgICAgICAgICAgICAgICAgICAgIFRoaXMgb2JqZWN0IGlzIGV4cGVjdGVkIHRvIGhhdmUgdGhlIGB1ZGlkYCBwcm9wZXJ0eSBjb250YWluaW5nIHRoZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkIGRldmljZSBJRC5cbiAqIEBwYXJhbSB7c3RyaW5nfSByZW1vdGVQYXRoIC0gVGhlIHJlbW90ZSBwYXRoIG9uIHRoZSBkZXZpY2UuIFRoaXMgdmFyaWFibGUgY2FuIGJlIHByZWZpeGVkIHdpdGhcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVuZGxlIGlkLCBzbyB0aGVuIHRoZSBmaWxlIHdpbGwgYmUgdXBsb2FkZWQgdG8gdGhlIGNvcnJlc3BvbmRpbmdcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwbGljYXRpb24gY29udGFpbmVyIGluc3RlYWQgb2YgdGhlIGRlZmF1bHQgbWVkaWEgZm9sZGVyLiBVc2VcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQDxhcHBfYnVuZGxlX2lkPjo8b3B0aW9uYWxfY29udGFpbmVyX3R5cGU+LzxwYXRoX3RvX3RoZV9maWxlX29yX2ZvbGRlcl9pbnNpZGVfY29udGFpbmVyPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXQgdG8gcHVsbCBhIGZpbGUgb3IgYSBmb2xkZXIgZnJvbSBhbiBhcHBsaWNhdGlvbiBjb250YWluZXIgb2YgdGhlIGdpdmVuIHR5cGUuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBvbmx5IHN1cHBvcnRlZCBjb250YWluZXIgdHlwZSBpcyAnZG9jdW1lbnRzJy4gSWYgdGhlIGNvbnRhaW5lciB0eXBlIGlzIG5vdCBzZXRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwbGljaXRseSBmb3IgYSBidW5kbGUgaWQsIHRoZW4gdGhlIGRlZmF1bHQgYXBwbGljYXRpb24gY29udGFpbmVyIGlzIGdvaW5nIHRvIGJlIG1vdW50ZWRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGFrYSAtLWNvbnRhaW5lciBpZnVzZSBhcmd1bWVudClcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5nLiBJZiBgQGNvbS5teWFwcC5ibGE6ZG9jdW1lbnRzLzExMS5wbmdgIGlzIHByb3ZpZGVkLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBPbiBNeSBpUGhvbmUvPGFwcCBuYW1lPmAgaW4gRmlsZXMgYXBwIHdpbGwgYmUgbW91bnRlZCBpbiB0aGUgaG9zdCBtYWNoaW5lLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEJhc2U2NCBlbmNvZGVkIGAxMTEucG5nYCB3aWxsIGJlIHB1c2hlZCBpbnRvIGBPbiBNeSBpUGhvbmUvPGFwcCBuYW1lPi8xMTEucG5nYFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzIGJhc2U2NCBkZWNvZGVkIGRhdGEuXG4gKiBAcGFyYW0ge3N0cmluZ30gYmFzZTY0RGF0YSAtIEJhc2UtNjQgZW5jb2RlZCBjb250ZW50IG9mIHRoZSBmaWxlIHRvIGJlIHVwbG9hZGVkLlxuICovXG5hc3luYyBmdW5jdGlvbiBwdXNoRmlsZVRvUmVhbERldmljZSAoZGV2aWNlLCByZW1vdGVQYXRoLCBiYXNlNjREYXRhKSB7XG4gIGF3YWl0IHZlcmlmeUlGdXNlUHJlc2VuY2UoKTtcbiAgY29uc3QgbW50Um9vdCA9IGF3YWl0IHRlbXBEaXIub3BlbkRpcigpO1xuICBsZXQgaXNVbm1vdW50U3VjY2Vzc2Z1bCA9IHRydWU7XG4gIHRyeSB7XG4gICAgbGV0IGRzdFBhdGggPSBwYXRoLnJlc29sdmUobW50Um9vdCwgcmVtb3RlUGF0aCk7XG4gICAgbGV0IGlmdXNlQXJncyA9IFsnLXUnLCBkZXZpY2UudWRpZCwgbW50Um9vdF07XG4gICAgaWYgKENPTlRBSU5FUl9QQVRIX1BBVFRFUk4udGVzdChyZW1vdGVQYXRoKSkge1xuICAgICAgY29uc3QgeyBidW5kbGVJZCwgcGF0aEluQ29udGFpbmVyLCBjb250YWluZXJUeXBlIH0gPSBhd2FpdCBwYXJzZUNvbnRhaW5lclBhdGgocmVtb3RlUGF0aCwgbW50Um9vdCk7XG4gICAgICBkc3RQYXRoID0gcGF0aEluQ29udGFpbmVyO1xuICAgICAgbG9nLmluZm8oYFBhcnNlZCBidW5kbGUgaWRlbnRpZmllciAnJHtidW5kbGVJZH0nIGZyb20gJyR7cmVtb3RlUGF0aH0nLiBgICtcbiAgICAgICAgYFdpbGwgcHV0IHRoZSBkYXRhIGludG8gJyR7ZHN0UGF0aH0nYCk7XG4gICAgICBpZnVzZUFyZ3MgPSBbXG4gICAgICAgICctdScsXG4gICAgICAgIGRldmljZS51ZGlkLFxuICAgICAgICBfLnRvTG93ZXIoY29udGFpbmVyVHlwZSkgPT09IElGVVNFX0NPTlRBSU5FUl9ET0NVTUVOVFMgPyAnLS1kb2N1bWVudHMnIDogJy0tY29udGFpbmVyJyxcbiAgICAgICAgYnVuZGxlSWQsXG4gICAgICAgIG1udFJvb3RcbiAgICAgIF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZlcmlmeUlzU3ViUGF0aChkc3RQYXRoLCBtbnRSb290KTtcbiAgICB9XG4gICAgYXdhaXQgbW91bnREZXZpY2UoZGV2aWNlLCBpZnVzZUFyZ3MpO1xuICAgIGlzVW5tb3VudFN1Y2Nlc3NmdWwgPSBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgaWYgKCFhd2FpdCBmcy5leGlzdHMocGF0aC5kaXJuYW1lKGRzdFBhdGgpKSkge1xuICAgICAgICBsb2cuZGVidWcoYFRoZSBkZXN0aW5hdGlvbiBmb2xkZXIgJyR7cGF0aC5kaXJuYW1lKGRzdFBhdGgpfScgZG9lcyBub3QgZXhpc3QuIENyZWF0aW5nLi4uYCk7XG4gICAgICAgIGF3YWl0IG1rZGlycChwYXRoLmRpcm5hbWUoZHN0UGF0aCkpO1xuICAgICAgfVxuICAgICAgYXdhaXQgZnMud3JpdGVGaWxlKGRzdFBhdGgsIEJ1ZmZlci5mcm9tKGJhc2U2NERhdGEsICdiYXNlNjQnKSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIC8vIFJhcmVseSB1bW91bnQgZmFpbHMsIHNvIHJldHJ5IG9uY2VcbiAgICAgIHJldHJ5KDIsIGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgYXdhaXQgZXhlYygndW1vdW50JywgW21udFJvb3RdKTtcbiAgICAgIH0pO1xuICAgICAgaXNVbm1vdW50U3VjY2Vzc2Z1bCA9IHRydWU7XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIGlmIChpc1VubW91bnRTdWNjZXNzZnVsKSB7XG4gICAgICBhd2FpdCBmcy5yaW1yYWYobW50Um9vdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZy53YXJuKGBVbW91bnQgaGFzIGZhaWxlZCwgc28gbm90IHJlbW92aW5nICcke21udFJvb3R9J2ApO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEdldCB0aGUgY29udGVudCBvZiBnaXZlbiBmaWxlIG9yIGZvbGRlciBmcm9tIGlPUyBTaW11bGF0b3IgYW5kIHJldHVybiBpdCBhcyBiYXNlLTY0IGVuY29kZWQgc3RyaW5nLlxuICogRm9sZGVyIGNvbnRlbnQgaXMgcmVjdXJzaXZlbHkgcGFja2VkIGludG8gYSB6aXAgYXJjaGl2ZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGV2aWNlIC0gVGhlIGRldmljZSBvYmplY3QsIHdoaWNoIHJlcHJlc2VudHMgdGhlIGRldmljZSB1bmRlciB0ZXN0LlxuICogICAgICAgICAgICAgICAgICAgICAgICAgIFRoaXMgb2JqZWN0IGlzIGV4cGVjdGVkIHRvIGhhdmUgdGhlIGB1ZGlkYCBwcm9wZXJ0eSBjb250YWluaW5nIHRoZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkIGRldmljZSBJRC5cbiAqIEBwYXJhbSB7c3RyaW5nfSByZW1vdGVQYXRoIC0gVGhlIHBhdGggdG8gYSBmaWxlIG9yIGEgZm9sZGVyLCB3aGljaCBleGlzdHMgaW4gdGhlIGNvcnJlc3BvbmRpbmcgYXBwbGljYXRpb25cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyIG9uIFNpbXVsYXRvci4gVXNlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEA8YXBwX2J1bmRsZV9pZD46PG9wdGlvbmFsX2NvbnRhaW5lcl90eXBlPi88cGF0aF90b190aGVfZmlsZV9vcl9mb2xkZXJfaW5zaWRlX2NvbnRhaW5lcj5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0IHRvIHB1bGwgYSBmaWxlIG9yIGEgZm9sZGVyIGZyb20gYW4gYXBwbGljYXRpb24gY29udGFpbmVyIG9mIHRoZSBnaXZlbiB0eXBlLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQb3NzaWJsZSBjb250YWluZXIgdHlwZXMgYXJlICdhcHAnLCAnZGF0YScsICdncm91cHMnLCAnPEEgc3BlY2lmaWMgQXBwIEdyb3VwIGNvbnRhaW5lcj4nLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgZGVmYXVsdCB0eXBlIGlzICdhcHAnLlxuICogQHBhcmFtIHtib29sZWFufSBpc0ZpbGUgLSBXaGV0aGVyIHRoZSBkZXN0aW5hdGlvbiBpdGVtIGlzIGEgZmlsZSBvciBhIGZvbGRlclxuICogQHJldHVybnMge3N0cmluZ30gQmFzZS02NCBlbmNvZGVkIGNvbnRlbnQgb2YgdGhlIGZpbGUuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHB1bGxGcm9tU2ltdWxhdG9yIChkZXZpY2UsIHJlbW90ZVBhdGgsIGlzRmlsZSkge1xuICBsZXQgcGF0aE9uU2VydmVyO1xuICBpZiAoQ09OVEFJTkVSX1BBVEhfUEFUVEVSTi50ZXN0KHJlbW90ZVBhdGgpKSB7XG4gICAgY29uc3QgeyBidW5kbGVJZCwgcGF0aEluQ29udGFpbmVyOiBkc3RQYXRoIH0gPSBhd2FpdCBwYXJzZUNvbnRhaW5lclBhdGgocmVtb3RlUGF0aCxcbiAgICAgIGFzeW5jIChhcHBCdW5kbGUsIGNvbnRhaW5lclR5cGUpID0+IGF3YWl0IGdldEFwcENvbnRhaW5lcihkZXZpY2UudWRpZCwgYXBwQnVuZGxlLCBudWxsLCBjb250YWluZXJUeXBlKSk7XG4gICAgbG9nLmluZm8oYFBhcnNlZCBidW5kbGUgaWRlbnRpZmllciAnJHtidW5kbGVJZH0nIGZyb20gJyR7cmVtb3RlUGF0aH0nLiBgICtcbiAgICAgIGBXaWxsIGdldCB0aGUgZGF0YSBmcm9tICcke2RzdFBhdGh9J2ApO1xuICAgIHBhdGhPblNlcnZlciA9IGRzdFBhdGg7XG4gIH0gZWxzZSB7XG4gICAgY29uc3Qgc2ltUm9vdCA9IGRldmljZS5nZXREaXIoKTtcbiAgICBwYXRoT25TZXJ2ZXIgPSBwYXRoLnBvc2l4LmpvaW4oc2ltUm9vdCwgcmVtb3RlUGF0aCk7XG4gICAgdmVyaWZ5SXNTdWJQYXRoKHBhdGhPblNlcnZlciwgc2ltUm9vdCk7XG4gICAgbG9nLmluZm8oYEdvdCB0aGUgZnVsbCBpdGVtIHBhdGg6ICR7cGF0aE9uU2VydmVyfWApO1xuICB9XG4gIGlmICghYXdhaXQgZnMuZXhpc3RzKHBhdGhPblNlcnZlcikpIHtcbiAgICBsb2cuZXJyb3JBbmRUaHJvdyhgVGhlIHJlbW90ZSAke2lzRmlsZSA/ICdmaWxlJyA6ICdmb2xkZXInfSBhdCAnJHtwYXRoT25TZXJ2ZXJ9JyBkb2VzIG5vdCBleGlzdGApO1xuICB9XG4gIGNvbnN0IGJ1ZmZlciA9IGlzRmlsZVxuICAgID8gYXdhaXQgZnMucmVhZEZpbGUocGF0aE9uU2VydmVyKVxuICAgIDogYXdhaXQgemlwLnRvSW5NZW1vcnlaaXAocGF0aE9uU2VydmVyKTtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGJ1ZmZlcikudG9TdHJpbmcoJ2Jhc2U2NCcpO1xufVxuXG4vKipcbiAqIEdldCB0aGUgY29udGVudCBvZiBnaXZlbiBmaWxlIG9yIGZvbGRlciBmcm9tIHRoZSByZWFsIGRldmljZSB1bmRlciB0ZXN0IGFuZCByZXR1cm4gaXQgYXMgYmFzZS02NCBlbmNvZGVkIHN0cmluZy5cbiAqIEZvbGRlciBjb250ZW50IGlzIHJlY3Vyc2l2ZWx5IHBhY2tlZCBpbnRvIGEgemlwIGFyY2hpdmUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRldmljZSAtIFRoZSBkZXZpY2Ugb2JqZWN0LCB3aGljaCByZXByZXNlbnRzIHRoZSBkZXZpY2UgdW5kZXIgdGVzdC5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBUaGlzIG9iamVjdCBpcyBleHBlY3RlZCB0byBoYXZlIHRoZSBgdWRpZGAgcHJvcGVydHkgY29udGFpbmluZyB0aGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZCBkZXZpY2UgSUQuXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVtb3RlUGF0aCAtIFRoZSBwYXRoIHRvIGFuIGV4aXN0aW5nIHJlbW90ZSBmaWxlIG9uIHRoZSBkZXZpY2UuIFRoaXMgdmFyaWFibGUgY2FuIGJlIHByZWZpeGVkIHdpdGhcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVuZGxlIGlkLCBzbyB0aGVuIHRoZSBmaWxlIHdpbGwgYmUgZG93bmxvYWRlZCBmcm9tIHRoZSBjb3JyZXNwb25kaW5nXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwcGxpY2F0aW9uIGNvbnRhaW5lciBpbnN0ZWFkIG9mIHRoZSBkZWZhdWx0IG1lZGlhIGZvbGRlci4gVXNlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEA8YXBwX2J1bmRsZV9pZD46PG9wdGlvbmFsX2NvbnRhaW5lcl90eXBlPi88cGF0aF90b190aGVfZmlsZV9vcl9mb2xkZXJfaW5zaWRlX2NvbnRhaW5lcj5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0IHRvIHB1bGwgYSBmaWxlIG9yIGEgZm9sZGVyIGZyb20gYW4gYXBwbGljYXRpb24gY29udGFpbmVyIG9mIHRoZSBnaXZlbiB0eXBlLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgb25seSBzdXBwb3J0ZWQgY29udGFpbmVyIHR5cGUgaXMgJ2RvY3VtZW50cycuIElmIHRoZSBjb250YWluZXIgdHlwZSBpcyBub3Qgc2V0XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cGxpY2l0bHkgZm9yIGEgYnVuZGxlIGlkLCB0aGVuIHRoZSBkZWZhdWx0IGFwcGxpY2F0aW9uIGNvbnRhaW5lciBpcyBnb2luZyB0byBiZSBtb3VudGVkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChha2EgLS1jb250YWluZXIgaWZ1c2UgYXJndW1lbnQpXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuZy4gSWYgYEBjb20ubXlhcHAuYmxhOmRvY3VtZW50cy8xMTEucG5nYCBpcyBwcm92aWRlZCxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgT24gTXkgaVBob25lLzxhcHAgbmFtZT5gIGluIEZpbGVzIGFwcCB3aWxsIGJlIG1vdW50ZWQgaW4gdGhlIGhvc3QgbWFjaGluZS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgT24gTXkgaVBob25lLzxhcHAgbmFtZT4vMTExLnBuZ2Agd2lsIGJlIHB1bGxlZCBpbnRvIHRoZSBtb3VudGVkIGhvc3QgbWFjaGluZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuZCBBcHBpdW0gcmV0dXJucyB0aGUgZGF0YSBhcyBiYXNlNjQtZW5jb2RlZCBzdHJpbmcgdG8gY2xpZW50LlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBAY29tLm15YXBwLmJsYTpkb2N1bWVudHMvYCBtZWFucyBgT24gTXkgaVBob25lLzxhcHAgbmFtZT5gLlxuICogQHBhcmFtIHtib29sZWFufSBpc0ZpbGUgLSBXaGV0aGVyIHRoZSBkZXN0aW5hdGlvbiBpdGVtIGlzIGEgZmlsZSBvciBhIGZvbGRlclxuICogQHJldHVybiB7c3RyaW5nfSBCYXNlLTY0IGVuY29kZWQgY29udGVudCBvZiB0aGUgcmVtb3RlIGZpbGVcbiAqL1xuYXN5bmMgZnVuY3Rpb24gcHVsbEZyb21SZWFsRGV2aWNlIChkZXZpY2UsIHJlbW90ZVBhdGgsIGlzRmlsZSkge1xuICBhd2FpdCB2ZXJpZnlJRnVzZVByZXNlbmNlKCk7XG4gIGNvbnN0IG1udFJvb3QgPSBhd2FpdCB0ZW1wRGlyLm9wZW5EaXIoKTtcbiAgbGV0IGlzVW5tb3VudFN1Y2Nlc3NmdWwgPSB0cnVlO1xuICB0cnkge1xuICAgIGxldCBkc3RQYXRoID0gcGF0aC5yZXNvbHZlKG1udFJvb3QsIHJlbW90ZVBhdGgpO1xuICAgIGxldCBpZnVzZUFyZ3MgPSBbJy11JywgZGV2aWNlLnVkaWQsIG1udFJvb3RdO1xuICAgIGlmIChDT05UQUlORVJfUEFUSF9QQVRURVJOLnRlc3QocmVtb3RlUGF0aCkpIHtcbiAgICAgIGNvbnN0IHsgYnVuZGxlSWQsIHBhdGhJbkNvbnRhaW5lciwgY29udGFpbmVyVHlwZSB9ID0gYXdhaXQgcGFyc2VDb250YWluZXJQYXRoKHJlbW90ZVBhdGgsIG1udFJvb3QpO1xuICAgICAgZHN0UGF0aCA9IHBhdGhJbkNvbnRhaW5lcjtcbiAgICAgIGxvZy5pbmZvKGBQYXJzZWQgYnVuZGxlIGlkZW50aWZpZXIgJyR7YnVuZGxlSWR9JyBmcm9tICcke3JlbW90ZVBhdGh9Jy4gYCArXG4gICAgICAgIGBXaWxsIGdldCB0aGUgZGF0YSBmcm9tICcke2RzdFBhdGh9J2ApO1xuICAgICAgaWZ1c2VBcmdzID0gW1xuICAgICAgICAnLXUnLFxuICAgICAgICBkZXZpY2UudWRpZCxcbiAgICAgICAgXy50b0xvd2VyKGNvbnRhaW5lclR5cGUpID09PSBJRlVTRV9DT05UQUlORVJfRE9DVU1FTlRTID8gJy0tZG9jdW1lbnRzJyA6ICctLWNvbnRhaW5lcicsXG4gICAgICAgIGJ1bmRsZUlkLFxuICAgICAgICBtbnRSb290XG4gICAgICBdO1xuICAgIH0gZWxzZSB7XG4gICAgICB2ZXJpZnlJc1N1YlBhdGgoZHN0UGF0aCwgbW50Um9vdCk7XG4gICAgfVxuICAgIGF3YWl0IG1vdW50RGV2aWNlKGRldmljZSwgaWZ1c2VBcmdzKTtcbiAgICBpc1VubW91bnRTdWNjZXNzZnVsID0gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghYXdhaXQgZnMuZXhpc3RzKGRzdFBhdGgpKSB7XG4gICAgICAgIGxvZy5lcnJvckFuZFRocm93KGBUaGUgcmVtb3RlICR7aXNGaWxlID8gJ2ZpbGUnIDogJ2ZvbGRlcid9IGF0ICcke2RzdFBhdGh9JyBkb2VzIG5vdCBleGlzdGApO1xuICAgICAgfVxuICAgICAgY29uc3QgYnVmZmVyID0gaXNGaWxlXG4gICAgICAgID8gYXdhaXQgZnMucmVhZEZpbGUoZHN0UGF0aClcbiAgICAgICAgOiBhd2FpdCB6aXAudG9Jbk1lbW9yeVppcChkc3RQYXRoKTtcbiAgICAgIHJldHVybiBCdWZmZXIuZnJvbShidWZmZXIpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgLy8gUmFyZWx5IHVtb3VudCBmYWlscywgc28gcmV0cnkgb25jZVxuICAgICAgcmV0cnkoMiwgYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgICAgICBhd2FpdCBleGVjKCd1bW91bnQnLCBbbW50Um9vdF0pO1xuICAgICAgfSk7XG4gICAgICBpc1VubW91bnRTdWNjZXNzZnVsID0gdHJ1ZTtcbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgaWYgKGlzVW5tb3VudFN1Y2Nlc3NmdWwpIHtcbiAgICAgIGF3YWl0IGZzLnJpbXJhZihtbnRSb290KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9nLndhcm4oYFVtb3VudCBoYXMgZmFpbGVkLCBzbyBub3QgcmVtb3ZpbmcgJyR7bW50Um9vdH0nYCk7XG4gICAgfVxuICB9XG59XG5cblxuLyoqXG4gKiBHZXQgYnVuZGxlSWRzIHdoaWNoIGNhbiBtb3VudCBieSBgLS1kb2N1bWVudHNgIGZsYWdcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdWRpZCAtIFRoZSB1ZGlkIG9mIHRoZSB0YXJnZXQgZGV2aWNlXG4gKiBAcmV0dXJucyB7QXJyYXk8c3RyaW5nPn0gQSBsaXN0IG9mIGJ1bmRsZSBpZHNcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0QXZhaWxhYmxlQnVuZGxlSWRzICh1ZGlkKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgeyBzdGRvdXQgfSA9IGF3YWl0IGV4ZWMoJ2lmdXNlJywgWyctdScsIHVkaWQsICctLWxpc3QtYXBwcyddKTtcbiAgICByZXR1cm4gc3Rkb3V0LnNwbGl0KEVPTClcbiAgICAgIC5tYXAoKGFwcCkgPT4gYXBwLnNwbGl0KCcsJylbMF0udHJpbSgpKVxuICAgICAgLmZpbHRlcigoYXBwKSA9PiAhXy5pc0VtcHR5KGFwcCkpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgbG9nLndhcm4oYENhbm5vdCBnZXQgYSBsaXN0IG9mIGJ1bmRsZUlkcy5gICtcbiAgICAgICAgICAgICBgRXJyb3IgY29kZTogJHtlfTsgc3RkZXJyIG91dHB1dDogJHtlLnN0ZGVycn1gKTtcbiAgfVxuICByZXR1cm4gW107XG59XG5cblxuY29tbWFuZHMucHVzaEZpbGUgPSBhc3luYyBmdW5jdGlvbiBwdXNoRmlsZSAocmVtb3RlUGF0aCwgYmFzZTY0RGF0YSkge1xuICBpZiAocmVtb3RlUGF0aC5lbmRzV2l0aCgnLycpKSB7XG4gICAgbG9nLmVycm9yQW5kVGhyb3coYEl0IGlzIGV4cGVjdGVkIHRoYXQgcmVtb3RlIHBhdGggcG9pbnRzIHRvIGEgZmlsZSBhbmQgbm90IHRvIGEgZm9sZGVyLiBgICtcbiAgICAgICAgICAgICAgICAgICAgICBgJyR7cmVtb3RlUGF0aH0nIGlzIGdpdmVuIGluc3RlYWRgKTtcbiAgfVxuICBpZiAoXy5pc0FycmF5KGJhc2U2NERhdGEpKSB7XG4gICAgLy8gc29tZSBjbGllbnRzIChhaGVtKSBqYXZhLCBzZW5kIGEgYnl0ZSBhcnJheSBlbmNvZGluZyB1dGY4IGNoYXJhY3RlcnNcbiAgICAvLyBpbnN0ZWFkIG9mIGEgc3RyaW5nLCB3aGljaCB3b3VsZCBiZSBpbmZpbml0ZWx5IGJldHRlciFcbiAgICBiYXNlNjREYXRhID0gQnVmZmVyLmZyb20oYmFzZTY0RGF0YSkudG9TdHJpbmcoJ3V0ZjgnKTtcbiAgfVxuICByZXR1cm4gdGhpcy5pc1NpbXVsYXRvcigpXG4gICAgPyBhd2FpdCBwdXNoRmlsZVRvU2ltdWxhdG9yKHRoaXMub3B0cy5kZXZpY2UsIHJlbW90ZVBhdGgsIGJhc2U2NERhdGEpXG4gICAgOiBhd2FpdCBwdXNoRmlsZVRvUmVhbERldmljZSh0aGlzLm9wdHMuZGV2aWNlLCByZW1vdGVQYXRoLCBiYXNlNjREYXRhKTtcbn07XG5cbmNvbW1hbmRzLnB1bGxGaWxlID0gYXN5bmMgZnVuY3Rpb24gcHVsbEZpbGUgKHJlbW90ZVBhdGgpIHtcbiAgaWYgKHJlbW90ZVBhdGguZW5kc1dpdGgoJy8nKSkge1xuICAgIGxvZy5lcnJvckFuZFRocm93KGBJdCBpcyBleHBlY3RlZCB0aGF0IHJlbW90ZSBwYXRoIHBvaW50cyB0byBhIGZpbGUgYW5kIG5vdCB0byBhIGZvbGRlci4gYCArXG4gICAgICAgICAgICAgICAgICAgICAgYCcke3JlbW90ZVBhdGh9JyBpcyBnaXZlbiBpbnN0ZWFkYCk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuaXNTaW11bGF0b3IoKVxuICAgID8gYXdhaXQgcHVsbEZyb21TaW11bGF0b3IodGhpcy5vcHRzLmRldmljZSwgcmVtb3RlUGF0aCwgdHJ1ZSlcbiAgICA6IGF3YWl0IHB1bGxGcm9tUmVhbERldmljZSh0aGlzLm9wdHMuZGV2aWNlLCByZW1vdGVQYXRoLCB0cnVlKTtcbn07XG5cbmNvbW1hbmRzLmdldFNpbUZpbGVGdWxsUGF0aCA9IGFzeW5jIGZ1bmN0aW9uIGdldFNpbUZpbGVGdWxsUGF0aCAocmVtb3RlUGF0aCkge1xuICBsZXQgYmFzZVBhdGggPSB0aGlzLm9wdHMuZGV2aWNlLmdldERpcigpO1xuICBsZXQgYXBwTmFtZSA9IG51bGw7XG5cbiAgaWYgKHRoaXMub3B0cy5hcHApIHtcbiAgICBsZXQgYXBwTmFtZVJlZ2V4ID0gbmV3IFJlZ0V4cChgXFxcXCR7cGF0aC5zZXB9KFtcXFxcdy1dK1xcXFwuYXBwKWApO1xuICAgIGxldCBhcHBOYW1lTWF0Y2hlcyA9IGFwcE5hbWVSZWdleC5leGVjKHRoaXMub3B0cy5hcHApO1xuICAgIGlmIChhcHBOYW1lTWF0Y2hlcykge1xuICAgICAgYXBwTmFtZSA9IGFwcE5hbWVNYXRjaGVzWzFdO1xuICAgIH1cbiAgfVxuICAvLyBkZS1hYnNvbHV0aXplIHRoZSBwYXRoXG4gIGlmIChzeXN0ZW0uaXNXaW5kb3dzKCkpIHtcbiAgICBpZiAocmVtb3RlUGF0aC5pbmRleG9mKCc6Ly8nKSA9PT0gMSkge1xuICAgICAgcmVtb3RlUGF0aCA9IHJlbW90ZVBhdGguc2xpY2UoNCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChyZW1vdGVQYXRoLmluZGV4T2YoJy8nKSA9PT0gMCkge1xuICAgICAgcmVtb3RlUGF0aCA9IHJlbW90ZVBhdGguc2xpY2UoMSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHJlbW90ZVBhdGguc3RhcnRzV2l0aChhcHBOYW1lKSkge1xuICAgIGxldCBmaW5kUGF0aCA9IGJhc2VQYXRoO1xuICAgIGlmICghdGhpcy5vcHRzLnBsYXRmb3JtVmVyc2lvbiB8fCB1dGlsLmNvbXBhcmVWZXJzaW9ucyh0aGlzLm9wdHMucGxhdGZvcm1WZXJzaW9uLCAnPj0nLCAnOC4wJykpIHtcbiAgICAgIC8vIHRoZSAuYXBwIGZpbGUgYXBwZWFycyBpbiAvQ29udGFpbmVycy9EYXRhIGFuZCAvQ29udGFpbmVycy9CdW5kbGUgYm90aC4gV2Ugb25seSB3YW50IC9CdW5kbGVcbiAgICAgIGZpbmRQYXRoID0gcGF0aC5yZXNvbHZlKGJhc2VQYXRoLCAnQ29udGFpbmVycycsICdCdW5kbGUnKTtcbiAgICB9XG4gICAgZmluZFBhdGggPSBmaW5kUGF0aC5yZXBsYWNlKC9cXHMvZywgJ1xcXFwgJyk7XG5cbiAgICBsZXQgeyBzdGRvdXQgfSA9IGF3YWl0IGV4ZWMoJ2ZpbmQnLCBbZmluZFBhdGgsICctbmFtZScsIGFwcE5hbWVdKTtcbiAgICBsZXQgYXBwUm9vdCA9IHN0ZG91dC5yZXBsYWNlKC9cXG4kLywgJycpO1xuICAgIGxldCBzdWJQYXRoID0gcmVtb3RlUGF0aC5zdWJzdHJpbmcoYXBwTmFtZS5sZW5ndGggKyAxKTtcbiAgICBsZXQgZnVsbFBhdGggPSBwYXRoLnJlc29sdmUoYXBwUm9vdCwgc3ViUGF0aCk7XG4gICAgbG9nLmRlYnVnKGBGaW5kaW5nIGFwcC1yZWxhdGl2ZSBmaWxlOiAnJHtmdWxsUGF0aH0nYCk7XG4gICAgcmV0dXJuIGZ1bGxQYXRoO1xuICB9XG5cbiAgbGV0IGZ1bGxQYXRoID0gcGF0aC5yZXNvbHZlKGJhc2VQYXRoLCByZW1vdGVQYXRoKTtcbiAgbG9nLmRlYnVnKGBGaW5kaW5nIHNpbS1yZWxhdGl2ZSBmaWxlOiAke2Z1bGxQYXRofWApO1xuICByZXR1cm4gZnVsbFBhdGg7XG59O1xuXG5jb21tYW5kcy5wdWxsRm9sZGVyID0gYXN5bmMgZnVuY3Rpb24gcHVsbEZvbGRlciAocmVtb3RlUGF0aCkge1xuICBpZiAoIXJlbW90ZVBhdGguZW5kc1dpdGgoJy8nKSkge1xuICAgIHJlbW90ZVBhdGggPSBgJHtyZW1vdGVQYXRofS9gO1xuICB9XG4gIHJldHVybiB0aGlzLmlzU2ltdWxhdG9yKClcbiAgICA/IGF3YWl0IHB1bGxGcm9tU2ltdWxhdG9yKHRoaXMub3B0cy5kZXZpY2UsIHJlbW90ZVBhdGgsIGZhbHNlKVxuICAgIDogYXdhaXQgcHVsbEZyb21SZWFsRGV2aWNlKHRoaXMub3B0cy5kZXZpY2UsIHJlbW90ZVBhdGgsIGZhbHNlKTtcbn07XG5cbmV4cG9ydCB7IGNvbW1hbmRzLCAvKiBmb3IgdGVzdGluZyAqLyBnZXRBdmFpbGFibGVCdW5kbGVJZHMsXG4gIC8qIGZvciB0ZXN0aW5nICovIHBhcnNlQ29udGFpbmVyUGF0aCB9O1xuZXhwb3J0IGRlZmF1bHQgY29tbWFuZHM7XG4iXSwiZmlsZSI6ImxpYi9jb21tYW5kcy9maWxlLW1vdmVtZW50LmpzIiwic291cmNlUm9vdCI6Ii4uLy4uLy4uIn0=
